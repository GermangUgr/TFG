
\newmintedfile[MakeConst]{python}{
	%linenos,
	firstline=1,
	lastline=2,
	numbersep=5pt,
	gobble=0,
	frame=lines,
	framesep=2mm,
	tabsize=3,
}

\newmintedfile[LCVQE]{python}{
	%linenos,
	firstline=3,
	lastline=3,
	numbersep=5pt,
	gobble=0,
	frame=lines,
	framesep=2mm,
	tabsize=3,
}

\newmintedfile[TVC]{python}{
	%linenos,
	firstline=5,
	lastline=6,
	numbersep=5pt,
	gobble=0,
	frame=lines,
	framesep=2mm,
	tabsize=3,
}

\newmintedfile[CECM]{python}{
	%linenos,
	firstline=8,
	lastline=9,
	numbersep=5pt,
	gobble=0,
	frame=lines,
	framesep=2mm,
	tabsize=3,
}

\newmintedfile[COPK]{python}{
	%linenos,
	firstline=11,
	lastline=12,
	numbersep=5pt,
	gobble=0,
	frame=lines,
	framesep=2mm,
	tabsize=3,
}

\newmintedfile[RDPM]{python}{
	%linenos,
	firstline=14,
	lastline=14,
	numbersep=5pt,
	gobble=0,
	frame=lines,
	framesep=2mm,
	tabsize=3,
}

\chapter{Implementación}\label{ch:Impl}

El objetivo de esta sección es dar una visión general de los métodos y herramientas empleadas para la implementación de los algoritmos expuestos en la sección \ref{ch:Algoritmos}, así como servir de guía para su utilización. Para ello tomamos como referencia la implementación de estos métodos en Matlab, resultado de un trabajo colaborativo en el que participan varios de los autores citados en este trabajo (citar github).

\section{Entorno de desarrollo}

Para la implementación es esencial disponer de un entorno de desarrollo que permita manejar de manera eficiente los múltiples archivos que contendrán el código. De igual forma debemos disponer de herramientas de depuración de fácil uso. Por ello el entorno recomendado es PyCharm, desarrollado por la empresa JetBrains.

PyCharm ofrece multitud de herramientas que hacen de desarrollo de grandes cantidades de código una tarea asequible, ayudándonos a seguir el estándar de programación de Python y poniendo a nuestra disposición un depurador de código completo.

\section{Bibliotecas empleadas en el desarrollo}

(Incluir referencias para todas las bibliotecas)

Para la implementación de las funcionalidades será necesario hacer uso de algunas bibliotecas de Python que nos permitan realizar cálculos y procedimientos básicos de forma sencilla.

Como no podía ser de otra manera, haremos uso de Numpy, una de las bibliotecas más completas y  básicas de Python. Numpy nos permite trabajar con matrices de manera eficiente, lo que es esencial para trabajar con grandes cantidades de datos que, a menudo, viene especificados en forma de matriz. Numpy integra operaciones con matrices, como la suma, la resta o la multiplicación y el cálculo de la inversa o del determinante de manera sencilla.

Emplearemos también la biblioteca math, que pone a nuestra disposición multitud de operaciones que no viene definidas en el lenguaje, como pueden ser el cálculo del factorial o el logaritmo.

La biblioteca Scipy es una de las bibliotecas para Python que integra métodos numéricos. Scipy ofrece una API sencilla de usar para el usuario, con funcionalidades como el cálculo de distintas medidas de distancia en un espacio dado, o el de funciones complejas. Un ejemplo de estas últimas pueden ser: el valor absoluto del logaritmo de la función Gamma para entradas reales (\texttt{gammaln}), o el de la derivada logarítmica de la función Gamma (\texttt{digamma}), cálculos necesarios para la implementación de algunos métodos.

Otra de las bibliotecas que podemos encontrar de utilidad para el desarrollo puede ser scikit-learn, una de las más ampliamente usadas por la comunidad para el desarrollo de aplicaciones de aprendizaje automático de cualquier tipo. Scikit-learn pone a nuestra disposición métodos clásicos, como \acf{KM}, o \acf{FKM}, que a menudo se emplean como métodos de inicialización en funcionalidades más complejas.

Por último, y aunque no sea estrictamente necesaria para la implementación, emplearemos la biblioteca matplotlib para obtener representaciones de los resultados obtenidos con los métodos implementados. Matplotlib permite un alto nivel de personalización en representaciones, haciendo posible incluir toda la información que sea necesaria para su comprensión. 

\section{Funcionalidades desarrolladas}

Uno de los objetivos de este trabajo es poner a disposición de la comunidad algunos de los métodos de clustering con restricciones que existen en la actualidad. A continuación se ofrece la documentación de los métodos implementados:

\subsection{Función \texttt{add\_constraints}}

La función \texttt{add\_constraints} crea un conjunto de restricciones en base a un conjunto de datos. La función que sigue para ello es simple, basta con seleccionar de forma aleatoria dos instancias y establecer una restricción de tipo \acs{ML} o \acs{CL} en función de si las instancias pertenecen o no a la misma clase. Dado que el método necesita como argumento las etiquetas (un oráculo) puede no ser de utilidad en un caso real, en el que no conozcamos la clase a la que pertenece cada objeto; sin embargo es válido para realizar experimentos. A continuación se muestra el prototipo del método:


\MakeConst{code.py}

Los parámetros de la función se detallan a continuación:

\begin{itemize}

	\item \textbf{\texttt{x}} {$\longrightarrow$ matriz de $n \times p$ que contiene el conjunto de datos}
	
	\item \textbf{\texttt{y}} {$\longrightarrow$ lista de de etiquetas de longitud $n$ etiquetas asociadas al conjunto de datos.}
	
	\item \textbf{\texttt{mat\_const}} {$\longrightarrow$ matriz de $n \times n$ de restricciones sobre las que se añadirán las nuevas.}
	
	\item \textbf{\texttt{nb\_const}} {$\longrightarrow$ número de restricciones a añadir.}
	
	\item \textbf{\texttt{noise}} {$\longrightarrow$ porcentaje de ruido a introducir en las restricciones.}
	
	\item \textbf{\texttt{prop}} {$\longrightarrow$ booleano que indica si las restricciones deben propagarse, es decir, si la matriz será simétrica respecto a la diagonal principal}

\end{itemize}

La función devuelve una matriz de $n \times n$ que contiene \texttt{nb\_const} nuevas restricciones. Cada elemento de la matriz indica si existe una restricción entre dos instancias y de que tipo es, esto es, $0$ indica que no existe restricción, $1$ indica que existe una de tipo \acs{ML}, y $-1$ una de tipo \acs{CL}.

\subsection{Función \texttt{COPKM}}

\COPK{code.py}

\subsection{Función \texttt{CECM}}

\CECM{code.py}

\subsection{Función \texttt{LCVQE}}

\LCVQE{code.py}

\subsection{Función \texttt{RDPM}}

\RDPM{code.py}

\subsection{Función \texttt{TVClust}}

\TVC{code.py}








